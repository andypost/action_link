<?php

/**
 * @file action_link.module
 * TODO: Enter file description here.
 */
 
/*

- 3 types of actionLink plugin:
  - Confirm form
  - page reload
  - AJAX

A derivative plugin (like blocks, apparently) is one of these with settings for:
  - various text strings
  - callbacks for validation
  - callbacks for action
  - toggling behaviour stuff
  - all that jazz
  
So therefore Flag has a 'template' it applies for some of these properties, as 
obviously things like the callbacks are not set by the admin user.


*/ 

/**
 * Implements hook_menu().
 */
function action_link_menu() {
  $items = array();

  // Our admin page to list ALs.
  $items['admin/structure/action_link'] = array(
    'title' => 'Action links',
    'route_name' => 'action_link_list',
  );

  // TODO: will we even have this??
  $items['admin/structure/action_link/add'] = array(
    'title' => 'Add action link',
    'route_name' => 'action_link_add',
    'type' => MENU_LOCAL_ACTION,
    'weight' => 1,
  );
  $items['admin/structure/action_link/manage/%robot'] = array(
    'title' => 'Edit robot',
    'route_name' => 'action_link_edit',
  );
  $items['admin/structure/action_link/manage/%robot/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  

  return $items;
}

function action_link_load($action_link_id) {
  return entity_load('action_link', $action_link_id);
}


function action_link_page_confirm($action_link, $new_state, $entity_type, $entity_id) {  
  dsm(func_get_args());
  
  /*
  load the AL plugin
  - does the new state make sense?
  - is access allowed for the user?
    - get the current state link controller
    - return result appropriate
  
  
  */
  
  
  $vars = get_class_vars('Drupal\Core\Entity\Annotation\EntityType');
  dsm($vars);
  
  return '!!!';
}

function action_link_page_four($one, $two, $three, $four) {
  return '4!';
}


  
  /*
  $items['flag/confirm/%/%flag/%'] = array(
    'title' => 'Flag confirm',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_confirm', 2, 3, 4),
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'file' => 'includes/flag.pages.inc',
    'type' => MENU_CALLBACK,
  );
  */

/**
 * Implements hook_entity_field_info().
 */
function Xaction_link_entity_field_info($entity_type) {
  /*
  $info['definitions']['action_link_foo'] = array(
    'type' => 'string_item',
    'list' => FALSE,
    'label' => t('The text'),
    'description' => t('A text property added by mymodule.'),
    'computed' => TRUE,
    'configurable' => TRUE,
    'class' => '\Drupal\mymodule\EntityComputedText',
  );
  
  //dsm($info);
  return $info;
  */
}  

/**
 * Implements hook_field_extra_fields().
 */
function action_link_field_extra_fields() {
  //dsm("extra fields!");
  $extra['node']['article']['display']['action_link_foo'] = array(
    'label' => t('Action link!'),
    'description' => 'action link!! desc!',
  );
  
  return $extra;
}

/**
 * Implements hook_entity_view().
 */
function action_link_entity_view(\Drupal\Core\Entity\EntityInterface $entity, \Drupal\entity\Entity\EntityDisplay $display, $view_mode, $langcode) {
  
  $info = Drupal\field\Field::fieldInfo()->getBundleExtraFields($entity->entityType(), $entity->bundle());
  dsm($info);
  
  // Fnd the things with our prefix. 
  
  // Only do the extra work if the component is configured to be displayed.
  // This assumes a 'mymodule_addition' extra field has been defined for the
  // entity bundle in hook_field_extra_fields().
  if ($display->getComponent('action_link_foo')) {
    $action_link = action_link_load('cake');
    dsm($action_link);
    
    $entity->content['action_link_foo'] = array(
      // Here we need:
      // - the action link
      '#prefix' => '<div>',
      '#markup' => 'Heyhyaction_link_entity_view!!',
      '#suffix' => '</div>',
      //'#theme' => 'mymodule_my_additional_field',
    );
  }
}
